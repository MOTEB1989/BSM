/**
 * Penetration Testing Agent
 * Integrates with Python pentest service for automated security scanning
 */

import fetch from 'node-fetch';
import logger from '../utils/logger.js';

const PENTEST_SERVICE_URL = process.env.PENTEST_SERVICE_URL || 'http://localhost:8001';

export class PentestAgent {
  /**
   * Start a security scan
   * @param {Object} options - Scan configuration
   * @returns {Promise<Object>} Scan result
   */
  static async startScan(options = {}) {
    try {
      const {
        targetUrl,
        scanTypes = ['all'],
        authToken = null,
        authType = 'bearer',
        apiEndpoints = null,
        maxDepth = 3
      } = options;

      if (!targetUrl) {
        throw new Error('Target URL is required');
      }

      logger.info('Starting penetration test scan', {
        targetUrl,
        scanTypes
      });

      const response = await fetch(`${PENTEST_SERVICE_URL}/api/scan`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          target_url: targetUrl,
          scan_types: scanTypes,
          auth_token: authToken,
          auth_type: authType,
          api_endpoints: apiEndpoints,
          max_depth: maxDepth
        })
      });

      if (!response.ok) {
        throw new Error(`Scan request failed: ${response.statusText}`);
      }

      const result = await response.json();
      
      logger.info('Scan initiated', {
        scanId: result.scan_id,
        status: result.status
      });

      return result;
    } catch (error) {
      logger.error('Failed to start scan', { error: error.message });
      throw error;
    }
  }

  /**
   * Get scan status and results
   * @param {string} scanId - Scan ID
   * @returns {Promise<Object>} Scan status
   */
  static async getScanStatus(scanId) {
    try {
      const response = await fetch(`${PENTEST_SERVICE_URL}/api/scan/${scanId}`);
      
      if (!response.ok) {
        throw new Error(`Failed to get scan status: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      logger.error('Failed to get scan status', { scanId, error: error.message });
      throw error;
    }
  }

  /**
   * Get detailed scan report
   * @param {string} scanId - Scan ID
   * @param {string} format - Report format (json, html, markdown)
   * @returns {Promise<Object>} Scan report
   */
  static async getScanReport(scanId, format = 'json') {
    try {
      const response = await fetch(
        `${PENTEST_SERVICE_URL}/api/scan/${scanId}/report?format=${format}`
      );
      
      if (!response.ok) {
        throw new Error(`Failed to get scan report: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      logger.error('Failed to get scan report', { scanId, error: error.message });
      throw error;
    }
  }

  /**
   * List all scans
   * @param {Object} options - Pagination options
   * @returns {Promise<Object>} List of scans
   */
  static async listScans(options = {}) {
    try {
      const { limit = 50, skip = 0 } = options;
      
      const response = await fetch(
        `${PENTEST_SERVICE_URL}/api/scans?limit=${limit}&skip=${skip}`
      );
      
      if (!response.ok) {
        throw new Error(`Failed to list scans: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      logger.error('Failed to list scans', { error: error.message });
      throw error;
    }
  }

  /**
   * Check if deployment should be blocked based on scan results
   * @param {Object} scanResults - Scan results
   * @returns {Object} Deployment decision
   */
  static shouldBlockDeployment(scanResults) {
    const { severity_breakdown = {} } = scanResults;
    const critical = severity_breakdown.critical || 0;
    const high = severity_breakdown.high || 0;

    if (critical > 0) {
      return {
        blocked: true,
        reason: `Deployment blocked: ${critical} critical vulnerabilities found`,
        severity: 'critical',
        action: 'Fix all critical vulnerabilities before deploying'
      };
    }

    if (high > 5) {
      return {
        blocked: true,
        reason: `Deployment blocked: ${high} high-severity vulnerabilities found`,
        severity: 'high',
        action: 'Reduce high-severity vulnerabilities to 5 or fewer'
      };
    }

    if (high > 0) {
      return {
        blocked: false,
        warning: `${high} high-severity vulnerabilities found`,
        severity: 'high',
        action: 'Review and plan remediation for high-severity issues'
      };
    }

    return {
      blocked: false,
      message: 'No critical security issues found',
      severity: 'ok'
    };
  }

  /**
   * Health check for pentest service
   * @returns {Promise<boolean>} Service health status
   */
  static async healthCheck() {
    try {
      const response = await fetch(`${PENTEST_SERVICE_URL}/health`, {
        timeout: 5000
      });
      return response.ok;
    } catch (error) {
      logger.warn('Pentest service health check failed', { error: error.message });
      return false;
    }
  }
}

export default PentestAgent;
