import fs from "fs";
import path from "path";
import logger from "../utils/logger.js";
import { AppError } from "../utils/errors.js";

/**
 * Orchestrator Service
 * Coordinates execution of multiple custom agents (Architect, Runner, Security)
 * and generates a consolidated report
 */

export const runOrchestration = async () => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").split(".")[0];
    const reportDir = path.join(process.cwd(), "reports");
    const reportFile = path.join(reportDir, `agents-summary-${timestamp}.md`);

    // Ensure reports directory exists
    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
    }

    logger.info({ timestamp }, "Starting orchestration");

    const results = {
      timestamp,
      architect: null,
      runner: null,
      security: null,
      errors: []
    };

    // Note: Custom agents are invoked via the task tool in the controller
    // This service prepares the structure for results collection
    
    logger.info({ reportFile }, "Orchestration structure prepared");

    return {
      success: true,
      reportFile,
      timestamp,
      results
    };
  } catch (err) {
    logger.error({ err }, "Orchestration failed");
    throw new AppError(`Orchestration failed: ${err.message}`, 500, "ORCHESTRATION_FAILED");
  }
};

/**
 * Generate Markdown report from orchestration results
 */
export const generateReport = (results) => {
  const lines = [];
  
  lines.push(`# BSM Agents Orchestration Report`);
  lines.push("");
  lines.push(`**Timestamp:** ${results.timestamp}`);
  lines.push("");

  // Architect Section
  lines.push("## 1. Architect Analysis");
  lines.push("");
  if (results.architect) {
    lines.push(results.architect);
  } else {
    lines.push("- No output from Architect agent");
  }
  lines.push("");

  // Runner Section
  lines.push("## 2. Runner Results");
  lines.push("");
  if (results.runner) {
    lines.push(results.runner);
  } else {
    lines.push("- No output from Runner agent");
  }
  lines.push("");

  // Security Section
  lines.push("## 3. Security Findings");
  lines.push("");
  if (results.security) {
    lines.push(results.security);
  } else {
    lines.push("- No output from Security agent");
  }
  lines.push("");

  // Errors Section (if any)
  if (results.errors && results.errors.length > 0) {
    lines.push("## Errors");
    lines.push("");
    results.errors.forEach(err => {
      lines.push(`- **${err.agent}**: ${err.error}`);
    });
    lines.push("");
  }

  // Summary Section
  lines.push("## Summary");
  lines.push("");
  lines.push(`- **Architect**: ${results.architect ? "✓ Completed" : "✗ Failed"}`);
  lines.push(`- **Runner**: ${results.runner ? "✓ Completed" : "✗ Failed"}`);
  lines.push(`- **Security**: ${results.security ? "✓ Completed" : "✗ Failed"}`);
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("*Generated by BSM Orchestrator*");

  return lines.join("\n");
};

/**
 * Save report to file
 */
export const saveReport = (reportFile, content) => {
  fs.writeFileSync(reportFile, content, "utf8");
  logger.info({ reportFile }, "Report saved");
};
