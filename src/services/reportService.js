import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import { getRealTimeMetrics, getTokenUsageByAgent, getConversationAnalytics } from './observatoryService.js';
import logger from '../utils/logger.js';

// Generate PDF report
export async function generatePDFReport(timeRange = '24h') {
  try {
    const metrics = await getRealTimeMetrics(timeRange);
    const tokenUsage = await getTokenUsageByAgent(timeRange);
    const conversationAnalytics = await getConversationAnalytics(timeRange);
    
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument();
      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
      
      // Title
      doc.fontSize(24).text('AI Agent Observatory Report', { align: 'center' });
      doc.moveDown();
      doc.fontSize(12).text(`Time Range: ${timeRange}`, { align: 'center' });
      doc.fontSize(12).text(`Generated: ${new Date().toISOString()}`, { align: 'center' });
      doc.moveDown(2);
      
      // Agent Performance Section
      doc.fontSize(18).text('Agent Performance Metrics', { underline: true });
      doc.moveDown();
      
      for (const metric of metrics) {
        doc.fontSize(14).text(`Agent: ${metric.agentId}`, { bold: true });
        doc.fontSize(11).text(`  Total Requests: ${metric.totalRequests}`);
        doc.text(`  Success Rate: ${metric.successRate}%`);
        doc.text(`  Avg Response Time: ${metric.avgResponseTime}ms`);
        doc.text(`  Max Response Time: ${metric.maxResponseTime}ms`);
        doc.text(`  Total Tokens: ${metric.totalTokens}`);
        doc.text(`  Total Cost: $${metric.totalCost}`);
        doc.moveDown();
      }
      
      // Token Usage Section
      doc.addPage();
      doc.fontSize(18).text('Token Usage by Agent', { underline: true });
      doc.moveDown();
      
      for (const usage of tokenUsage) {
        doc.fontSize(14).text(`Agent: ${usage.agentId}`, { bold: true });
        doc.fontSize(11).text(`  Total Tokens: ${usage.totalTokens}`);
        doc.text(`  Prompt Tokens: ${usage.promptTokens}`);
        doc.text(`  Completion Tokens: ${usage.completionTokens}`);
        doc.text(`  Request Count: ${usage.requestCount}`);
        doc.moveDown();
      }
      
      // Conversation Analytics Section
      doc.addPage();
      doc.fontSize(18).text('Conversation Analytics', { underline: true });
      doc.moveDown();
      
      doc.fontSize(11).text(`Total Conversations: ${conversationAnalytics.totalConversations}`);
      doc.text(`Avg Messages per Conversation: ${conversationAnalytics.avgMessagesPerConversation}`);
      doc.text(`Avg Sentiment Score: ${conversationAnalytics.avgSentimentScore}`);
      doc.moveDown();
      
      doc.fontSize(14).text('Sentiment Distribution:', { bold: true });
      doc.fontSize(11).text(`  Positive: ${conversationAnalytics.sentimentDistribution.positive}`);
      doc.text(`  Neutral: ${conversationAnalytics.sentimentDistribution.neutral}`);
      doc.text(`  Negative: ${conversationAnalytics.sentimentDistribution.negative}`);
      
      // Footer
      doc.fontSize(9).text(
        'Generated by BSM AI Agent Observatory',
        50,
        doc.page.height - 50,
        { align: 'center' }
      );
      
      doc.end();
    });
  } catch (err) {
    logger.error({ err }, 'Failed to generate PDF report');
    throw err;
  }
}

// Generate Excel report
export async function generateExcelReport(timeRange = '24h') {
  try {
    const metrics = await getRealTimeMetrics(timeRange);
    const tokenUsage = await getTokenUsageByAgent(timeRange);
    const conversationAnalytics = await getConversationAnalytics(timeRange);
    
    const workbook = new ExcelJS.Workbook();
    
    // Agent Performance Sheet
    const metricsSheet = workbook.addWorksheet('Agent Performance');
    metricsSheet.columns = [
      { header: 'Agent ID', key: 'agentId', width: 20 },
      { header: 'Total Requests', key: 'totalRequests', width: 15 },
      { header: 'Successful Requests', key: 'successfulRequests', width: 18 },
      { header: 'Success Rate (%)', key: 'successRate', width: 15 },
      { header: 'Avg Response Time (ms)', key: 'avgResponseTime', width: 20 },
      { header: 'Max Response Time (ms)', key: 'maxResponseTime', width: 20 },
      { header: 'Total Tokens', key: 'totalTokens', width: 15 },
      { header: 'Total Cost ($)', key: 'totalCost', width: 15 }
    ];
    
    metricsSheet.addRows(metrics);
    
    // Style header row
    metricsSheet.getRow(1).font = { bold: true };
    metricsSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' }
    };
    
    // Token Usage Sheet
    const tokenSheet = workbook.addWorksheet('Token Usage');
    tokenSheet.columns = [
      { header: 'Agent ID', key: 'agentId', width: 20 },
      { header: 'Total Tokens', key: 'totalTokens', width: 15 },
      { header: 'Prompt Tokens', key: 'promptTokens', width: 15 },
      { header: 'Completion Tokens', key: 'completionTokens', width: 18 },
      { header: 'Request Count', key: 'requestCount', width: 15 }
    ];
    
    tokenSheet.addRows(tokenUsage);
    tokenSheet.getRow(1).font = { bold: true };
    tokenSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' }
    };
    
    // Conversation Analytics Sheet
    const analyticsSheet = workbook.addWorksheet('Conversation Analytics');
    analyticsSheet.columns = [
      { header: 'Metric', key: 'metric', width: 30 },
      { header: 'Value', key: 'value', width: 20 }
    ];
    
    analyticsSheet.addRows([
      { metric: 'Total Conversations', value: conversationAnalytics.totalConversations },
      { metric: 'Avg Messages per Conversation', value: conversationAnalytics.avgMessagesPerConversation },
      { metric: 'Avg Sentiment Score', value: conversationAnalytics.avgSentimentScore },
      { metric: 'Positive Sentiment Count', value: conversationAnalytics.sentimentDistribution.positive },
      { metric: 'Neutral Sentiment Count', value: conversationAnalytics.sentimentDistribution.neutral },
      { metric: 'Negative Sentiment Count', value: conversationAnalytics.sentimentDistribution.negative }
    ]);
    
    analyticsSheet.getRow(1).font = { bold: true };
    analyticsSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' }
    };
    
    // Generate buffer
    const buffer = await workbook.xlsx.writeBuffer();
    return buffer;
  } catch (err) {
    logger.error({ err }, 'Failed to generate Excel report');
    throw err;
  }
}

export default {
  generatePDFReport,
  generateExcelReport
};
