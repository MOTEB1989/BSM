/**
 * Penetration Testing Controller
 */

import { PentestAgent } from '../agents/PentestAgent.js';
import logger from '../utils/logger.js';

class PentestController {
  /**
   * Start a penetration test scan
   */
  async startScan(req, res) {
    try {
      const {
        targetUrl,
        scanTypes,
        authToken,
        authType,
        apiEndpoints,
        maxDepth
      } = req.body;

      if (!targetUrl) {
        return res.status(400).json({
          error: 'Target URL is required'
        });
      }

      const result = await PentestAgent.startScan({
        targetUrl,
        scanTypes,
        authToken,
        authType,
        apiEndpoints,
        maxDepth
      });

      res.json(result);
    } catch (error) {
      logger.error('Start scan failed', { error: error.message });
      res.status(500).json({
        error: 'Failed to start scan',
        message: error.message
      });
    }
  }

  /**
   * Get scan status
   */
  async getScanStatus(req, res) {
    try {
      const { scanId } = req.params;
      const status = await PentestAgent.getScanStatus(scanId);
      res.json(status);
    } catch (error) {
      logger.error('Get scan status failed', { error: error.message });
      res.status(500).json({
        error: 'Failed to get scan status',
        message: error.message
      });
    }
  }

  /**
   * Get scan report
   */
  async getScanReport(req, res) {
    try {
      const { scanId } = req.params;
      const { format = 'json' } = req.query;
      
      const report = await PentestAgent.getScanReport(scanId, format);
      
      if (format === 'html') {
        res.set('Content-Type', 'text/html');
        res.send(report.report);
      } else if (format === 'markdown') {
        res.set('Content-Type', 'text/markdown');
        res.send(report.report);
      } else {
        res.json(report);
      }
    } catch (error) {
      logger.error('Get scan report failed', { error: error.message });
      res.status(500).json({
        error: 'Failed to get scan report',
        message: error.message
      });
    }
  }

  /**
   * List all scans
   */
  async listScans(req, res) {
    try {
      const { limit = 50, skip = 0 } = req.query;
      const scans = await PentestAgent.listScans({
        limit: parseInt(limit),
        skip: parseInt(skip)
      });
      res.json(scans);
    } catch (error) {
      logger.error('List scans failed', { error: error.message });
      res.status(500).json({
        error: 'Failed to list scans',
        message: error.message
      });
    }
  }

  /**
   * Check if deployment should be allowed based on security scan
   */
  async deploymentCheck(req, res) {
    try {
      const { scanId } = req.body;

      if (!scanId) {
        return res.status(400).json({
          error: 'Scan ID is required'
        });
      }

      const scanResults = await PentestAgent.getScanStatus(scanId);
      const decision = PentestAgent.shouldBlockDeployment(scanResults);

      res.json({
        scanId,
        decision,
        scanResults
      });
    } catch (error) {
      logger.error('Deployment check failed', { error: error.message });
      res.status(500).json({
        error: 'Failed to check deployment readiness',
        message: error.message
      });
    }
  }

  /**
   * Health check
   */
  async healthCheck(req, res) {
    try {
      const healthy = await PentestAgent.healthCheck();
      res.json({
        status: healthy ? 'healthy' : 'unhealthy',
        service: 'pentest-agent'
      });
    } catch (error) {
      res.status(503).json({
        status: 'unhealthy',
        service: 'pentest-agent',
        error: error.message
      });
    }
  }
}

export const pentestController = new PentestController();
