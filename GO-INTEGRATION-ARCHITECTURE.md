# BSM Platform - Go Language Integration Architecture

> **Generated by**: BSM Autonomous Architect  
> **Date**: 2026-02-06  
> **Version**: 1.0.0  
> **Status**: Design Specification

## Executive Summary

This document outlines the architecture for integrating **Go microservices** into the existing Node.js-based BSM platform. The hybrid architecture leverages Go's performance, concurrency, and type safety for compute-intensive operations while maintaining the Node.js ecosystem for rapid development and AI integrations.

### Key Benefits

✅ **Performance**: 10-100x faster execution for CPU-bound operations  
✅ **Concurrency**: Native goroutines for parallel processing  
✅ **Type Safety**: Compile-time error detection  
✅ **Resource Efficiency**: Lower memory footprint  
✅ **Scalability**: Built-in concurrency primitives  

---

## Strategic Rationale

### Why Add Go to BSM?

#### Current Node.js Strengths
- ✅ Rapid development with rich ecosystem
- ✅ Excellent for I/O-bound operations
- ✅ Strong AI/ML library integration (OpenAI, etc.)
- ✅ Dynamic frontend integration

#### Node.js Limitations Addressed by Go
- ⚠️ Single-threaded event loop bottlenecks
- ⚠️ Performance limitations for CPU-intensive tasks
- ⚠️ Memory management challenges at scale
- ⚠️ Lack of compile-time type safety

#### Ideal Use Cases for Go Services
1. **Document Processing**: PDF parsing, OCR, text extraction
2. **Data Analytics**: Large-scale data aggregation and analysis
3. **Real-time Processing**: Stream processing, event handling
4. **Background Workers**: Job queues, scheduled tasks
5. **API Gateway**: High-throughput request routing
6. **Search Services**: Full-text search, indexing

---

## Hybrid Architecture Design

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Layer                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │  Admin UI    │  │   Chat UI    │  │ GitHub Pages │         │
│  │  (HTML/JS)   │  │  (Vue 3)     │  │   Frontend   │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
└─────────────────────────────────────────────────────────────────┘
                          │  HTTP/REST
┌─────────────────────────────────────────────────────────────────┐
│                   API Gateway (Node.js)                         │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  Express.js App                                      │      │
│  │  - CORS, Auth, Rate Limiting                        │      │
│  │  - Request Routing & Load Balancing                 │      │
│  │  - Service Discovery                                │      │
│  └──────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
                 │                              │
    ┌────────────┴─────────┐         ┌─────────┴──────────┐
    │                      │         │                    │
┌───▼─────────────────────▼──┐   ┌──▼───────────────────▼─────┐
│   Node.js Services          │   │   Go Microservices         │
│  ┌─────────────────────┐   │   │  ┌─────────────────────┐   │
│  │ AI/ML Service       │   │   │  │ Document Processor  │   │
│  │ (GPT Integration)   │   │   │  │ (PDF, OCR)          │   │
│  └─────────────────────┘   │   │  └─────────────────────┘   │
│  ┌─────────────────────┐   │   │  ┌─────────────────────┐   │
│  │ Agent Orchestrator  │   │   │  │ Analytics Engine    │   │
│  │ (Business Logic)    │   │   │  │ (Data Processing)   │   │
│  └─────────────────────┘   │   │  └─────────────────────┘   │
│  ┌─────────────────────┐   │   │  ┌─────────────────────┐   │
│  │ Knowledge Service   │   │   │  │ Search Service      │   │
│  │ (Document Mgmt)     │   │   │  │ (Full-Text Search)  │   │
│  └─────────────────────┘   │   │  └─────────────────────┘   │
│                             │   │  ┌─────────────────────┐   │
│                             │   │  │ Worker Service      │   │
│                             │   │  │ (Background Jobs)   │   │
│                             │   │  └─────────────────────┘   │
└─────────────────────────────┘   └────────────────────────────┘
                 │                              │
                 └──────────────┬───────────────┘
                                │
┌───────────────────────────────▼─────────────────────────────────┐
│                      Shared Data Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ PostgreSQL  │  │    Redis    │  │ Object Store│            │
│  │ (Primary DB)│  │   (Cache)   │  │    (S3)     │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

### Service Communication Patterns

#### 1. HTTP/REST (Primary)
```
Node.js ←→ HTTP/JSON ←→ Go Service
```

**Use For**: Synchronous request-response patterns  
**Pros**: Simple, standard, debuggable  
**Cons**: Higher latency, no built-in retry  

#### 2. Message Queue (Async)
```
Node.js → Queue (Redis/RabbitMQ) → Go Worker
```

**Use For**: Background jobs, batch processing  
**Pros**: Decoupled, fault-tolerant, scalable  
**Cons**: More complex, eventual consistency  

#### 3. gRPC (High Performance)
```
Node.js ←→ gRPC/Protobuf ←→ Go Service
```

**Use For**: Internal high-throughput communication  
**Pros**: Fast, type-safe, bi-directional streaming  
**Cons**: More complex setup, binary protocol  

---

## Proposed Go Services

### Phase 1: Foundation Services (Q1 2026)

#### 1.1 Document Processing Service

**Purpose**: High-performance document parsing and analysis

**Responsibilities**:
- PDF text extraction
- Document format conversion
- OCR processing
- Metadata extraction
- Content sanitization

**Technology Stack**:
- `github.com/ledongthuc/pdf` - PDF parsing
- `github.com/otiai10/gosseract` - OCR
- `github.com/go-chi/chi` - HTTP router
- `github.com/rs/zerolog` - Structured logging

**API Endpoints**:
```
POST /api/v1/documents/parse
POST /api/v1/documents/convert
POST /api/v1/documents/ocr
GET  /api/v1/documents/{id}/metadata
```

**Performance Target**:
- PDF parsing: <500ms for 100-page document
- OCR: <2s per page
- Concurrent processing: 100+ documents

#### 1.2 Search Service

**Purpose**: High-performance full-text search and indexing

**Responsibilities**:
- Full-text indexing
- Query processing
- Result ranking
- Fuzzy search
- Autocomplete

**Technology Stack**:
- `github.com/blevesearch/bleve` - Full-text search
- `github.com/gin-gonic/gin` - Web framework
- `github.com/elastic/go-elasticsearch` - Elasticsearch client

**API Endpoints**:
```
POST /api/v1/search/index
POST /api/v1/search/query
GET  /api/v1/search/suggest
DELETE /api/v1/search/index/{id}
```

**Performance Target**:
- Query latency: <50ms (95th percentile)
- Indexing throughput: 1000+ docs/sec
- Concurrent queries: 1000+ QPS

### Phase 2: Advanced Services (Q2 2026)

#### 2.1 Analytics Engine

**Purpose**: Real-time data processing and aggregation

**Responsibilities**:
- Usage analytics
- Report generation
- Data aggregation
- Time-series analysis
- Dashboard metrics

**Technology Stack**:
- `github.com/gonum/gonum` - Numerical computing
- `github.com/segmentio/kafka-go` - Event streaming
- `github.com/prometheus/client_golang` - Metrics

**API Endpoints**:
```
POST /api/v1/analytics/events
GET  /api/v1/analytics/reports/{type}
GET  /api/v1/analytics/metrics
POST /api/v1/analytics/aggregate
```

#### 2.2 Worker Service

**Purpose**: Background job processing

**Responsibilities**:
- Scheduled tasks
- Batch operations
- Email notifications
- Data exports
- Cleanup jobs

**Technology Stack**:
- `github.com/robfig/cron` - Cron scheduler
- `github.com/hibiken/asynq` - Task queue
- `github.com/go-redis/redis` - Redis client

**API Endpoints**:
```
POST /api/v1/jobs/schedule
GET  /api/v1/jobs/{id}/status
DELETE /api/v1/jobs/{id}
GET  /api/v1/jobs/stats
```

### Phase 3: Infrastructure Services (Q3 2026)

#### 3.1 API Gateway (Go)

**Purpose**: High-performance request routing

**Responsibilities**:
- Request routing
- Load balancing
- Rate limiting
- Authentication
- Caching

**Technology Stack**:
- `github.com/traefik/traefik` - Reverse proxy
- `github.com/go-redis/redis` - Caching
- `github.com/golang-jwt/jwt` - JWT auth

---

## Integration Patterns

### Pattern 1: Node.js Orchestrator with Go Workers

**Scenario**: Document processing pipeline

```javascript
// Node.js Orchestrator (src/services/documentService.js)
export async function processDocument(file) {
  // 1. Node.js: Validate and prepare
  const validated = await validateDocument(file);
  
  // 2. Go Service: Heavy processing
  const processed = await fetch('http://go-doc-processor:8080/api/v1/documents/parse', {
    method: 'POST',
    body: validated
  });
  
  // 3. Node.js: AI analysis
  const analysis = await gptService.analyze(processed.data);
  
  // 4. Node.js: Store results
  return await storeResults(analysis);
}
```

```go
// Go Service (services/document-processor/main.go)
func parseDocument(w http.ResponseWriter, r *http.Request) {
    // Heavy CPU-bound processing
    doc := extractPDF(r.Body)
    text := performOCR(doc)
    metadata := extractMetadata(doc)
    
    json.NewEncoder(w).Write(Response{
        Text: text,
        Metadata: metadata,
    })
}
```

### Pattern 2: Async Job Queue

**Scenario**: Batch processing

```javascript
// Node.js: Queue job
import Redis from 'ioredis';
const redis = new Redis();

export async function queueBatchJob(items) {
  const jobId = generateId();
  await redis.lpush('job:queue', JSON.stringify({
    id: jobId,
    type: 'batch_process',
    items: items,
    timestamp: Date.now()
  }));
  return jobId;
}
```

```go
// Go Worker: Process jobs
func processJobs() {
    for {
        job, err := redis.BRPop("job:queue").Result()
        if err != nil {
            continue
        }
        
        go func(job Job) {
            // Parallel processing
            results := processInParallel(job.Items)
            notifyCompletion(job.ID, results)
        }(parseJob(job))
    }
}
```

### Pattern 3: gRPC Service Mesh

**Scenario**: High-frequency internal communication

```protobuf
// Proto definition (proto/analytics.proto)
syntax = "proto3";

service Analytics {
  rpc TrackEvent(Event) returns (Response);
  rpc GetMetrics(Query) returns (Metrics);
}

message Event {
  string user_id = 1;
  string event_type = 2;
  map<string, string> properties = 3;
}
```

```javascript
// Node.js Client
import grpc from '@grpc/grpc-js';
const client = new AnalyticsClient('go-analytics:50051');

client.trackEvent({
  userId: 'user123',
  eventType: 'agent_run',
  properties: { agentId: 'legal-agent' }
});
```

```go
// Go Server
func (s *server) TrackEvent(ctx context.Context, event *pb.Event) (*pb.Response, error) {
    // Fast, concurrent processing
    go processEvent(event)
    return &pb.Response{Success: true}, nil
}
```

---

## Project Structure

### Directory Layout

```
BSM/
├── src/                         # Node.js application
│   ├── services/
│   │   ├── goServiceClient.js   # Go service HTTP client
│   │   └── grpcClient.js        # gRPC client wrapper
│   └── ...
├── services/                    # Go microservices
│   ├── document-processor/
│   │   ├── cmd/
│   │   │   └── server/
│   │   │       └── main.go
│   │   ├── internal/
│   │   │   ├── api/
│   │   │   ├── processor/
│   │   │   └── storage/
│   │   ├── pkg/
│   │   │   └── pdf/
│   │   ├── go.mod
│   │   ├── go.sum
│   │   ├── Dockerfile
│   │   └── README.md
│   ├── search-service/
│   │   ├── cmd/
│   │   ├── internal/
│   │   ├── pkg/
│   │   ├── go.mod
│   │   └── Dockerfile
│   ├── analytics-engine/
│   │   └── ...
│   └── worker-service/
│       └── ...
├── proto/                       # Protobuf definitions
│   ├── analytics.proto
│   ├── document.proto
│   └── search.proto
├── docker-compose.hybrid.yml    # Full stack
├── kubernetes/                  # K8s manifests
│   ├── node-deployment.yaml
│   └── go-services.yaml
└── docs/
    └── GO-INTEGRATION-ARCHITECTURE.md
```

---

## Deployment Architecture

### Development Environment

```yaml
# docker-compose.hybrid.yml
version: '3.8'

services:
  # Node.js API Gateway
  node-api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - GO_DOCUMENT_SERVICE=http://go-doc-processor:8080
      - GO_SEARCH_SERVICE=http://go-search:8081
    depends_on:
      - redis
      - postgres
  
  # Go Document Processor
  go-doc-processor:
    build: ./services/document-processor
    ports:
      - "8080:8080"
    environment:
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=debug
  
  # Go Search Service
  go-search:
    build: ./services/search-service
    ports:
      - "8081:8080"
    environment:
      - ELASTICSEARCH_URL=http://elasticsearch:9200
  
  # Shared Infrastructure
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_DB=bsm
      - POSTGRES_USER=bsm
      - POSTGRES_PASSWORD=secret
  
  elasticsearch:
    image: elasticsearch:8.12.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
```

### Production Deployment

#### Option 1: Docker Swarm/Compose

```yaml
# Production optimizations
services:
  node-api:
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1'
          memory: 512M
  
  go-doc-processor:
    deploy:
      replicas: 5
      resources:
        limits:
          cpus: '2'
          memory: 256M
```

#### Option 2: Kubernetes

```yaml
# kubernetes/go-document-processor.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go-doc-processor
spec:
  replicas: 5
  selector:
    matchLabels:
      app: go-doc-processor
  template:
    metadata:
      labels:
        app: go-doc-processor
    spec:
      containers:
      - name: processor
        image: ghcr.io/lexbank/bsm-doc-processor:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: go-doc-processor
spec:
  selector:
    app: go-doc-processor
  ports:
  - port: 8080
    targetPort: 8080
```

#### Option 3: Render.com (Hybrid)

```yaml
# render.yaml
services:
  # Node.js API
  - type: web
    name: bsm-api
    env: node
    buildCommand: "npm ci"
    startCommand: "npm start"
    envVars:
      - key: GO_DOCUMENT_SERVICE
        value: https://bsm-doc-processor.onrender.com
  
  # Go Document Processor
  - type: web
    name: bsm-doc-processor
    env: go
    buildCommand: "cd services/document-processor && go build -o bin/server cmd/server/main.go"
    startCommand: "./services/document-processor/bin/server"
```

---

## Service Communication

### Node.js Go Service Client

```javascript
// src/services/goServiceClient.js
import fetch from 'node-fetch';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('GoServiceClient');

class GoServiceClient {
  constructor(baseUrl, options = {}) {
    this.baseUrl = baseUrl;
    this.timeout = options.timeout || 30000;
    this.retries = options.retries || 3;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
        headers: {
          'Content-Type': 'application/json',
          'X-Request-ID': options.correlationId,
          ...options.headers,
        },
      });

      if (!response.ok) {
        throw new Error(`Go service error: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      logger.error({ err: error, url }, 'Go service request failed');
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  // Document Processor Service
  async parseDocument(file, options = {}) {
    return this.request('/api/v1/documents/parse', {
      method: 'POST',
      body: JSON.stringify({ file }),
      correlationId: options.correlationId,
    });
  }

  // Search Service
  async search(query, options = {}) {
    return this.request('/api/v1/search/query', {
      method: 'POST',
      body: JSON.stringify({ query }),
      correlationId: options.correlationId,
    });
  }
}

// Export configured clients
export const documentProcessorClient = new GoServiceClient(
  process.env.GO_DOCUMENT_SERVICE || 'http://localhost:8080'
);

export const searchServiceClient = new GoServiceClient(
  process.env.GO_SEARCH_SERVICE || 'http://localhost:8081'
);
```

### Go Service Health Check

```go
// services/document-processor/internal/api/health.go
package api

import (
    "encoding/json"
    "net/http"
    "time"
)

type HealthResponse struct {
    Status    string    `json:"status"`
    Timestamp time.Time `json:"timestamp"`
    Service   string    `json:"service"`
    Version   string    `json:"version"`
}

func HealthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    response := HealthResponse{
        Status:    "healthy",
        Timestamp: time.Now(),
        Service:   "document-processor",
        Version:   "1.0.0",
    }
    
    json.NewEncoder(w).Encode(response)
}
```

---

## Performance Benchmarks

### Expected Performance Improvements

| Operation | Node.js | Go | Improvement |
|-----------|---------|-----|-------------|
| PDF Parsing (100 pages) | 5000ms | 500ms | **10x faster** |
| JSON Processing (1MB) | 150ms | 15ms | **10x faster** |
| Concurrent Requests (1000) | 2500ms | 250ms | **10x faster** |
| Memory Usage (baseline) | 200MB | 20MB | **10x less** |
| Cold Start Time | 2000ms | 50ms | **40x faster** |

### Load Testing Targets

**Document Processing**:
- Throughput: 100+ documents/second
- Latency (p95): <500ms
- Concurrent connections: 1000+

**Search Service**:
- QPS: 1000+ queries/second
- Latency (p95): <50ms
- Index size: 1M+ documents

---

## Monitoring and Observability

### Metrics Collection

```go
// services/document-processor/internal/metrics/metrics.go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    RequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "document_processor_requests_total",
            Help: "Total number of requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    RequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "document_processor_request_duration_seconds",
            Help: "Request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    DocumentsProcessed = promauto.NewCounter(
        prometheus.CounterOpts{
            Name: "documents_processed_total",
            Help: "Total number of documents processed",
        },
    )
)
```

### Structured Logging

```go
// Using zerolog
import "github.com/rs/zerolog/log"

func processDocument(doc Document) error {
    log.Info().
        Str("document_id", doc.ID).
        Int("pages", doc.Pages).
        Msg("Processing document")
    
    start := time.Now()
    defer func() {
        log.Info().
            Str("document_id", doc.ID).
            Dur("duration", time.Since(start)).
            Msg("Document processing completed")
    }()
    
    // Processing logic...
    return nil
}
```

### Distributed Tracing

```go
// Using OpenTelemetry
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func parseDocumentWithTracing(ctx context.Context, doc Document) error {
    tracer := otel.Tracer("document-processor")
    ctx, span := tracer.Start(ctx, "parseDocument")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("document.id", doc.ID),
        attribute.Int("document.pages", doc.Pages),
    )
    
    // Processing with sub-spans
    err := extractText(ctx, doc)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}
```

---

## Security Considerations

### Authentication & Authorization

```go
// JWT authentication middleware
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // Validate JWT
        claims, err := validateToken(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // Add claims to context
        ctx := context.WithValue(r.Context(), "user", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### Input Validation

```go
// Request validation
type ParseRequest struct {
    FileURL  string `json:"file_url" validate:"required,url"`
    Format   string `json:"format" validate:"required,oneof=pdf docx txt"`
    MaxPages int    `json:"max_pages" validate:"min=1,max=1000"`
}

func validateRequest(req ParseRequest) error {
    validate := validator.New()
    return validate.Struct(req)
}
```

### Rate Limiting

```go
// Token bucket rate limiter
import "golang.org/x/time/rate"

var limiter = rate.NewLimiter(rate.Limit(100), 200) // 100 req/s, burst 200

func rateLimitMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }
        next.ServeHTTP(w, r)
    })
}
```

---

## Migration Strategy

### Phase 1: Proof of Concept (Weeks 1-2)

- [ ] Set up Go development environment
- [ ] Create simple Go HTTP service
- [ ] Implement health check endpoint
- [ ] Deploy alongside Node.js app
- [ ] Test Node.js → Go communication

### Phase 2: Document Processor (Weeks 3-6)

- [ ] Develop PDF parsing service
- [ ] Implement OCR functionality
- [ ] Create comprehensive tests
- [ ] Deploy to staging
- [ ] Performance benchmarking
- [ ] Production deployment

### Phase 3: Search Service (Weeks 7-10)

- [ ] Implement full-text search
- [ ] Create indexing pipeline
- [ ] Integrate with Node.js
- [ ] Load testing
- [ ] Production deployment

### Phase 4: Infrastructure (Weeks 11-14)

- [ ] Set up monitoring (Prometheus/Grafana)
- [ ] Implement distributed tracing
- [ ] Add alerting
- [ ] Document runbooks
- [ ] Team training

---

## Testing Strategy

### Unit Tests (Go)

```go
// services/document-processor/internal/processor/parser_test.go
package processor

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestParsePDF(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
        wantErr  bool
    }{
        {
            name:     "valid PDF",
            input:    "testdata/sample.pdf",
            expected: "Sample text content",
            wantErr:  false,
        },
        {
            name:     "invalid PDF",
            input:    "testdata/invalid.pdf",
            expected: "",
            wantErr:  true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := ParsePDF(tt.input)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.expected, result)
            }
        })
    }
}
```

### Integration Tests

```javascript
// tests/integration/go-services.test.js
import { documentProcessorClient } from '../../src/services/goServiceClient.js';
import { expect } from 'chai';

describe('Go Document Processor Integration', () => {
  it('should parse PDF document', async () => {
    const result = await documentProcessorClient.parseDocument({
      url: 'https://example.com/sample.pdf',
      format: 'pdf',
    });
    
    expect(result).to.have.property('text');
    expect(result).to.have.property('pages');
    expect(result.pages).to.be.greaterThan(0);
  });
  
  it('should handle errors gracefully', async () => {
    try {
      await documentProcessorClient.parseDocument({
        url: 'invalid-url',
      });
      expect.fail('Should have thrown error');
    } catch (error) {
      expect(error.message).to.include('Go service error');
    }
  });
});
```

### Load Testing

```yaml
# tests/load/document-processor.yml
config:
  target: "http://localhost:8080"
  phases:
    - duration: 60
      arrivalRate: 10
      name: "Warm up"
    - duration: 300
      arrivalRate: 50
      name: "Sustained load"
    - duration: 120
      arrivalRate: 100
      name: "Spike test"

scenarios:
  - name: "Parse PDF"
    flow:
      - post:
          url: "/api/v1/documents/parse"
          json:
            file_url: "https://example.com/sample.pdf"
            format: "pdf"
```

---

## Cost Analysis

### Development Costs

| Item | Node.js Only | Hybrid (Node.js + Go) | Delta |
|------|--------------|----------------------|-------|
| Development Time | 100% | 120% | +20% |
| Learning Curve | Low | Medium | +30% |
| Infrastructure | $100/mo | $120/mo | +20% |

### Operational Savings

| Metric | Node.js | Go | Savings |
|--------|---------|-----|---------|
| CPU Usage (avg) | 80% | 20% | **75% reduction** |
| Memory (per instance) | 512MB | 64MB | **87% reduction** |
| Response Time | 500ms | 50ms | **90% faster** |
| Instances Needed | 10 | 2 | **80% fewer** |

**Monthly Cost Projection**:
- Node.js Only: $500/mo (10 instances × $50)
- Hybrid: $250/mo (3 Node.js × $50 + 2 Go × $25)
- **Savings**: $250/mo (50% reduction)

---

## Team Readiness

### Required Skills

#### Go Development
- [ ] Go syntax and idioms
- [ ] Concurrency (goroutines, channels)
- [ ] Standard library
- [ ] Testing practices
- [ ] Deployment & operations

#### DevOps
- [ ] Multi-service deployment
- [ ] Container orchestration
- [ ] Service discovery
- [ ] Monitoring & alerting

### Training Plan

**Week 1-2**: Go Fundamentals
- Online courses (Tour of Go, Effective Go)
- Code reviews of sample projects
- Pair programming sessions

**Week 3-4**: BSM Specific
- Architecture overview
- Integration patterns
- Testing strategies
- Deployment procedures

---

## Success Metrics

### Technical KPIs

- **Performance**: 10x improvement in CPU-bound operations
- **Scalability**: Handle 10x more concurrent users
- **Reliability**: 99.9% uptime for Go services
- **Cost**: 50% reduction in infrastructure costs

### Business KPIs

- **User Experience**: <100ms API response times (p95)
- **Throughput**: Process 1000+ documents/hour
- **Resource Efficiency**: 80% reduction in compute costs

---

## Conclusion

The hybrid Node.js/Go architecture provides the best of both worlds:

✅ **Node.js**: Rapid development, AI integrations, dynamic workflows  
✅ **Go**: High performance, concurrency, type safety, efficiency  

This architecture positions BSM for:
- **Scalability**: Handle 10-100x traffic growth
- **Performance**: Sub-second response times
- **Cost Efficiency**: 50%+ savings on infrastructure
- **Reliability**: Fault-tolerant, distributed system
- **Innovation**: Best tool for each job

### Next Steps

1. **Immediate**: Review and approve architecture
2. **Week 1**: Set up Go development environment
3. **Week 2**: Create proof-of-concept service
4. **Month 1**: Deploy document processor to production
5. **Quarter 1**: Complete Phase 1 migration

---

**Document Owner**: BSM Autonomous Architect  
**Review Cycle**: Monthly  
**Last Updated**: 2026-02-06  
**Status**: Awaiting Approval
