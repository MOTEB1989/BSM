# Agent Orchestration Patterns

> **Generated by**: BSM Autonomous Architect  
> **Date**: 2026-02-06  
> **Purpose**: Design patterns for multi-agent systems

## Overview

This document describes architectural patterns for orchestrating multiple AI agents in the BSM platform. It covers agent design, communication patterns, workflow automation, and best practices for building scalable agent-based systems.

---

## Table of Contents

1. [Agent Design Patterns](#agent-design-patterns)
2. [Communication Patterns](#communication-patterns)
3. [Workflow Orchestration](#workflow-orchestration)
4. [Agent Configuration](#agent-configuration)
5. [Error Handling and Recovery](#error-handling-and-recovery)
6. [Performance Optimization](#performance-optimization)
7. [Testing Strategies](#testing-strategies)

---

## Agent Design Patterns

### 1. Single Responsibility Agent

**Pattern**: Each agent handles one specific domain or task type.

**Example**: Legal Agent
```yaml
id: legal-agent
name: Legal Services Agent
role: Provides legal document analysis and consultation
modelProvider: openai
modelKey: lexnexus
modelName: gpt-4o-mini
actions:
  - create_file
  - analyze_document
specialization: legal-analysis
```

**Benefits**:
- Clear scope and purpose
- Easy to maintain
- Simple testing
- Better error isolation

**Use Cases**:
- Document analysis
- Contract review
- Compliance checking
- Legal research

### 2. Composite Agent

**Pattern**: Agent that delegates to multiple specialized sub-agents.

**Example**: Legal Operations Agent
```yaml
id: legal-ops-agent
name: Legal Operations Coordinator
role: Orchestrates multiple legal tasks
modelProvider: openai
modelKey: lexnexus
modelName: gpt-4o
subAgents:
  - legal-agent
  - governance-agent
  - compliance-agent
actions:
  - delegate_task
  - aggregate_results
```

**Benefits**:
- Handles complex workflows
- Reuses specialized agents
- Reduces code duplication
- Scalable architecture

**Use Cases**:
- Multi-step processes
- Cross-domain tasks
- Workflow automation
- Complex decision-making

### 3. Stateful Agent

**Pattern**: Agent that maintains conversation state across interactions.

**Example**: Conversational Legal Advisor
```yaml
id: legal-advisor-agent
name: Conversational Legal Advisor
role: Interactive legal consultation with memory
modelProvider: openai
modelKey: lexnexus
modelName: gpt-4o
stateManagement:
  enabled: true
  storage: redis
  ttl: 3600
actions:
  - recall_context
  - update_context
  - provide_advice
```

**Benefits**:
- Maintains conversation context
- Personalized responses
- Multi-turn interactions
- Better user experience

**Use Cases**:
- Chatbots
- Advisory services
- Ongoing consultations
- User assistance

---

## Communication Patterns

### 1. Request-Response Pattern

**Flow**:
```
Client → Agent → GPT API → Agent → Client
```

**Implementation**:
```javascript
// src/runners/agentRunner.js
export const runAgent = async ({ agentId, input }) => {
  // 1. Load agent config
  const agent = await loadAgent(agentId);
  
  // 2. Execute request
  const result = await executeAgent(agent, input);
  
  // 3. Return response
  return { output: result };
};
```

**Best For**:
- Simple queries
- One-time tasks
- Stateless operations

### 2. Pipeline Pattern

**Flow**:
```
Input → Agent1 → Agent2 → Agent3 → Output
```

**Example**: Document Processing Pipeline
```javascript
// Pseudo-code
const pipeline = async (document) => {
  // Stage 1: Extract text
  const text = await textExtractorAgent.run(document);
  
  // Stage 2: Analyze content
  const analysis = await analyzerAgent.run(text);
  
  // Stage 3: Generate summary
  const summary = await summarizerAgent.run(analysis);
  
  // Stage 4: Format output
  const formatted = await formatterAgent.run(summary);
  
  return formatted;
};
```

**Best For**:
- Multi-step processing
- Data transformation
- Sequential workflows

### 3. Broadcast Pattern

**Flow**:
```
Input → Orchestrator → Agent1
                    → Agent2
                    → Agent3
                    ↓
        Aggregator ← Results
```

**Example**: Multi-Expert Analysis
```javascript
// Pseudo-code
const multiExpertAnalysis = async (input) => {
  // Broadcast to multiple agents
  const results = await Promise.all([
    legalAgent.run(input),
    governanceAgent.run(input),
    complianceAgent.run(input)
  ]);
  
  // Aggregate results
  return aggregateResults(results);
};
```

**Best For**:
- Parallel processing
- Consensus building
- Multi-perspective analysis

### 4. Event-Driven Pattern

**Flow**:
```
Event Bus
  ↓
Event → Handler → Agent → Action
```

**Example**: Automated Response System
```javascript
// Pseudo-code
eventBus.on("document_uploaded", async (event) => {
  const { documentId, type } = event;
  
  // Route to appropriate agent
  const agent = selectAgent(type);
  const result = await agent.process(documentId);
  
  // Emit completion event
  eventBus.emit("processing_complete", { documentId, result });
});
```

**Best For**:
- Asynchronous processing
- Decoupled systems
- Reactive architectures

---

## Workflow Orchestration

### 1. Sequential Workflow

**Pattern**: Tasks execute one after another.

```yaml
workflow:
  name: contract-review
  steps:
    - id: extract
      agent: text-extractor-agent
      input: $document
      
    - id: analyze
      agent: legal-agent
      input: $extract.output
      
    - id: report
      agent: report-generator-agent
      input: $analyze.output
```

**Implementation**:
```javascript
const executeSequential = async (workflow, initialInput) => {
  let input = initialInput;
  const results = {};
  
  for (const step of workflow.steps) {
    const agent = await loadAgent(step.agent);
    const result = await runAgent({ 
      agentId: agent.id, 
      input: resolveInput(step.input, results, input) 
    });
    results[step.id] = result;
    input = result.output;
  }
  
  return results;
};
```

### 2. Parallel Workflow

**Pattern**: Multiple tasks execute simultaneously.

```yaml
workflow:
  name: comprehensive-review
  parallel:
    - id: legal-review
      agent: legal-agent
      input: $document
      
    - id: compliance-check
      agent: compliance-agent
      input: $document
      
    - id: risk-assessment
      agent: risk-agent
      input: $document
      
  aggregate: merge-results
```

**Implementation**:
```javascript
const executeParallel = async (workflow, input) => {
  const tasks = workflow.parallel.map(step => 
    runAgent({ agentId: step.agent, input })
  );
  
  const results = await Promise.all(tasks);
  
  return aggregateResults(results, workflow.aggregate);
};
```

### 3. Conditional Workflow

**Pattern**: Execution path depends on conditions.

```yaml
workflow:
  name: smart-routing
  steps:
    - id: classify
      agent: classifier-agent
      input: $document
      
    - id: route
      condition: $classify.category
      branches:
        legal:
          agent: legal-agent
        governance:
          agent: governance-agent
        general:
          agent: general-agent
```

**Implementation**:
```javascript
const executeConditional = async (workflow, input) => {
  const classifyResult = await runAgent({
    agentId: workflow.steps[0].agent,
    input
  });
  
  const category = classifyResult.category;
  const branch = workflow.steps[1].branches[category];
  
  return await runAgent({
    agentId: branch.agent,
    input
  });
};
```

### 4. Retry and Fallback Workflow

**Pattern**: Automatic retry with fallback options.

```yaml
workflow:
  name: resilient-execution
  steps:
    - id: primary
      agent: advanced-agent
      retry:
        maxAttempts: 3
        backoff: exponential
      fallback:
        agent: simple-agent
```

**Implementation**:
```javascript
const executeWithRetry = async (step, input) => {
  const { maxAttempts = 3, backoff = "exponential" } = step.retry;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await runAgent({ agentId: step.agent, input });
    } catch (err) {
      if (attempt === maxAttempts) {
        // Try fallback
        if (step.fallback) {
          return await runAgent({ 
            agentId: step.fallback.agent, 
            input 
          });
        }
        throw err;
      }
      
      // Wait before retry
      const delay = backoff === "exponential" 
        ? Math.pow(2, attempt) * 1000 
        : 1000;
      await sleep(delay);
    }
  }
};
```

---

## Agent Configuration

### Configuration Schema

```yaml
# Agent Configuration v1.0
schema: agent/v1

# Identity
id: unique-agent-id
name: Human-Readable Agent Name
version: 1.0.0
description: Detailed description of agent capabilities

# Model Configuration
modelProvider: openai
modelKey: lexnexus  # or bsm, brinder
modelName: gpt-4o-mini
temperature: 0.7
maxTokens: 1000

# Role and Behavior
role: Provides legal analysis and document review
systemPrompt: |
  You are a legal expert specializing in contract analysis.
  Always provide citations and reasoning for your conclusions.

# Capabilities
actions:
  - create_file
  - analyze_document
  - generate_report

# Permissions
permissions:
  read:
    - knowledge/*
    - data/documents/*
  write:
    - data/reports/*
  execute:
    - external_api

# Resource Limits
limits:
  inputLength: 4000
  timeout: 30000
  concurrency: 5

# Dependencies
dependencies:
  - knowledge-base
  - legal-templates

# Monitoring
monitoring:
  logLevel: info
  metrics:
    - execution_time
    - token_usage
    - error_rate
```

### Configuration Best Practices

**1. Versioning**:
```yaml
id: legal-agent
version: 1.2.0
changelog:
  - 1.2.0: Added governance analysis
  - 1.1.0: Improved accuracy
  - 1.0.0: Initial release
```

**2. Environment-Specific Configs**:
```yaml
# Base config
base: &base
  modelProvider: openai
  modelName: gpt-4o-mini

# Development
development:
  <<: *base
  modelKey: bsm
  temperature: 0.8

# Production
production:
  <<: *base
  modelKey: lexnexus
  temperature: 0.7
```

**3. Feature Flags**:
```yaml
features:
  experimental_analysis: false
  enhanced_citations: true
  multi_language: true
```

---

## Error Handling and Recovery

### Error Categories

#### 1. Validation Errors
```javascript
// Input validation
if (!input || input.length > maxLength) {
  throw new AppError(
    "Invalid input",
    400,
    "VALIDATION_ERROR"
  );
}
```

#### 2. Agent Execution Errors
```javascript
// Agent not found
if (!agent) {
  throw new AppError(
    `Agent not found: ${agentId}`,
    404,
    "AGENT_NOT_FOUND"
  );
}

// Action not permitted
if (!agent.actions.includes(action)) {
  throw new AppError(
    `Action not permitted: ${action}`,
    403,
    "ACTION_NOT_ALLOWED"
  );
}
```

#### 3. External API Errors
```javascript
// OpenAI API error
try {
  const result = await callOpenAI(params);
} catch (err) {
  if (err.status === 429) {
    // Rate limit - retry with backoff
    await sleep(5000);
    return await callOpenAI(params);
  }
  throw new AppError(
    "GPT service unavailable",
    503,
    "GPT_ERROR"
  );
}
```

### Recovery Strategies

#### 1. Graceful Degradation
```javascript
const runAgentWithFallback = async (agentId, input) => {
  try {
    return await runAgent({ agentId, input });
  } catch (err) {
    logger.warn({ err, agentId }, "Primary agent failed, using fallback");
    return await runAgent({ 
      agentId: "fallback-agent", 
      input 
    });
  }
};
```

#### 2. Circuit Breaker
```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = "CLOSED";
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === "OPEN") {
      if (Date.now() < this.nextAttempt) {
        throw new Error("Circuit breaker is OPEN");
      }
      this.state = "HALF_OPEN";
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (err) {
      this.onFailure();
      throw err;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = "CLOSED";
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = "OPEN";
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
```

#### 3. Retry with Exponential Backoff
```javascript
const retry = async (fn, maxAttempts = 3) => {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxAttempts - 1) throw err;
      
      const delay = Math.pow(2, i) * 1000;
      await sleep(delay);
    }
  }
};
```

---

## Performance Optimization

### 1. Caching Strategies

#### Agent Configuration Cache
```javascript
const agentCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

const loadAgentCached = async (agentId) => {
  const cached = agentCache.get(agentId);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.agent;
  }
  
  const agent = await loadAgent(agentId);
  agentCache.set(agentId, { agent, timestamp: Date.now() });
  return agent;
};
```

#### Knowledge Base Cache
```javascript
let knowledgeCache = null;
let knowledgeCacheTime = 0;

const loadKnowledgeCached = async () => {
  const now = Date.now();
  if (knowledgeCache && now - knowledgeCacheTime < CACHE_TTL) {
    return knowledgeCache;
  }
  
  knowledgeCache = await loadKnowledge();
  knowledgeCacheTime = now;
  return knowledgeCache;
};
```

### 2. Connection Pooling

```javascript
import fetch from "node-fetch";
import { Agent } from "http";

const httpAgent = new Agent({
  keepAlive: true,
  keepAliveMsecs: 30000,
  maxSockets: 50
});

const callOpenAI = async (params) => {
  return await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    agent: httpAgent,
    // ... other options
  });
};
```

### 3. Batch Processing

```javascript
const processBatch = async (inputs, agentId) => {
  const batchSize = 10;
  const results = [];
  
  for (let i = 0; i < inputs.length; i += batchSize) {
    const batch = inputs.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(input => runAgent({ agentId, input }))
    );
    results.push(...batchResults);
  }
  
  return results;
};
```

### 4. Streaming Responses

```javascript
const streamAgentResponse = async (agentId, input, res) => {
  const agent = await loadAgent(agentId);
  
  const stream = await openai.chat.completions.create({
    model: agent.modelName,
    messages: [{ role: "user", content: input }],
    stream: true
  });
  
  for await (const chunk of stream) {
    const content = chunk.choices[0]?.delta?.content;
    if (content) {
      res.write(content);
    }
  }
  
  res.end();
};
```

---

## Testing Strategies

### 1. Unit Testing Agents

```javascript
// test/agents/legalAgent.test.js
import { runAgent } from "../src/runners/agentRunner.js";

describe("Legal Agent", () => {
  it("should analyze contract", async () => {
    const input = "Review this contract: ...";
    const result = await runAgent({ 
      agentId: "legal-agent", 
      input 
    });
    
    expect(result.output).toBeDefined();
    expect(result.output).toContain("analysis");
  });
  
  it("should reject invalid input", async () => {
    await expect(
      runAgent({ agentId: "legal-agent", input: "" })
    ).rejects.toThrow();
  });
});
```

### 2. Integration Testing Workflows

```javascript
// test/workflows/contractReview.test.js
describe("Contract Review Workflow", () => {
  it("should complete full workflow", async () => {
    const workflow = {
      steps: [
        { agent: "text-extractor-agent" },
        { agent: "legal-agent" },
        { agent: "report-generator-agent" }
      ]
    };
    
    const result = await executeWorkflow(workflow, sampleDocument);
    
    expect(result).toHaveProperty("report");
    expect(result.report).toBeDefined();
  });
});
```

### 3. Mock Testing

```javascript
// test/mocks/mockAgent.js
export const mockRunAgent = jest.fn(async ({ agentId, input }) => {
  return {
    output: `Mock response for ${agentId}: ${input}`
  };
});
```

### 4. Load Testing

```javascript
// test/load/agents.load.test.js
import autocannon from "autocannon";

describe("Agent Load Test", () => {
  it("should handle 100 concurrent requests", async () => {
    const result = await autocannon({
      url: "http://localhost:3000/api/agents/run",
      connections: 100,
      duration: 30,
      method: "POST",
      body: JSON.stringify({ 
        agentId: "legal-agent", 
        input: "Test input" 
      }),
      headers: { "Content-Type": "application/json" }
    });
    
    expect(result.errors).toBe(0);
    expect(result.timeouts).toBe(0);
  });
});
```

---

## Best Practices Summary

### Agent Design
✓ Single responsibility per agent  
✓ Clear, descriptive agent names  
✓ Explicit permission model  
✓ Comprehensive error handling  
✓ Timeout configuration  

### Orchestration
✓ Use appropriate pattern for use case  
✓ Handle failures gracefully  
✓ Log all agent interactions  
✓ Monitor performance  
✓ Implement circuit breakers  

### Configuration
✓ Version agent configurations  
✓ Use environment-specific settings  
✓ Document all capabilities  
✓ Validate configurations  
✓ Keep secrets secure  

### Performance
✓ Cache where appropriate  
✓ Use connection pooling  
✓ Batch similar requests  
✓ Stream large responses  
✓ Monitor resource usage  

### Testing
✓ Unit test each agent  
✓ Integration test workflows  
✓ Load test under expected load  
✓ Mock external dependencies  
✓ Test error scenarios  

---

**Document Owner**: BSM Autonomous Architect  
**Version**: 1.0.0  
**Last Updated**: 2026-02-06
