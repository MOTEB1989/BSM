"""
BSU Penetration Testing Service - Main Application
Automated security scanning and vulnerability detection
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import Dict, Optional

import structlog
import uvicorn
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

from scanners.zap_scanner import ZAPScanner
from scanners.sql_injection import SQLInjectionScanner
from scanners.xss_scanner import XSSScanner
from scanners.csrf_scanner import CSRFScanner
from scanners.api_tester import APITester
from report.generator import ReportGenerator
from notifications.notifier import Notifier
from database.mongo_client import MongoClient
from config import settings

# Configure structured logging
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)
logger = structlog.get_logger()


class ScanRequest(BaseModel):
    """Request model for security scan"""
    target_url: str = Field(..., description="Target URL to scan")
    scan_types: list[str] = Field(default=["all"], description="Types of scans to perform")
    auth_token: Optional[str] = Field(None, description="Authentication token for authenticated testing")
    auth_type: str = Field(default="bearer", description="Authentication type (bearer, basic, cookie)")
    api_endpoints: Optional[list[str]] = Field(None, description="Specific API endpoints to test")
    max_depth: int = Field(default=3, description="Maximum crawl depth")


class ScanResponse(BaseModel):
    """Response model for scan results"""
    scan_id: str
    status: str
    message: str


class ScanStatus(BaseModel):
    """Scan status model"""
    scan_id: str
    status: str
    progress: int
    vulnerabilities_found: int
    severity_breakdown: Dict[str, int]


# Global state
mongo_client: Optional[MongoClient] = None
zap_scanner: Optional[ZAPScanner] = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifespan"""
    global mongo_client, zap_scanner
    
    logger.info("Starting BSU Penetration Testing Service")
    
    # Initialize MongoDB
    mongo_client = MongoClient(settings.MONGODB_URI)
    await mongo_client.connect()
    
    # Initialize ZAP Scanner
    zap_scanner = ZAPScanner(
        zap_proxy=settings.ZAP_PROXY,
        api_key=settings.ZAP_API_KEY
    )
    await zap_scanner.start()
    
    logger.info("Service initialized successfully")
    
    yield
    
    # Cleanup
    logger.info("Shutting down service")
    if mongo_client:
        await mongo_client.close()
    if zap_scanner:
        await zap_scanner.stop()


# Initialize FastAPI app
app = FastAPI(
    title="BSU Penetration Testing Service",
    description="Automated security scanning and vulnerability detection",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "bsu-pentest",
        "version": "1.0.0"
    }


@app.post("/api/scan", response_model=ScanResponse)
async def start_scan(request: ScanRequest, background_tasks: BackgroundTasks):
    """
    Start a penetration testing scan
    
    Supported scan types:
    - sql: SQL Injection
    - xss: Cross-Site Scripting
    - csrf: Cross-Site Request Forgery
    - api: API endpoint testing
    - zap: Full OWASP ZAP scan
    - all: All scan types
    """
    try:
        # Generate scan ID
        import uuid
        scan_id = str(uuid.uuid4())
        
        logger.info(
            "scan_requested",
            scan_id=scan_id,
            target=request.target_url,
            scan_types=request.scan_types
        )
        
        # Store initial scan status
        await mongo_client.store_scan({
            "scan_id": scan_id,
            "target_url": request.target_url,
            "scan_types": request.scan_types,
            "status": "queued",
            "progress": 0,
            "vulnerabilities": [],
            "created_at": None  # Will be set by MongoDB
        })
        
        # Queue scan in background
        background_tasks.add_task(
            perform_scan,
            scan_id=scan_id,
            request=request
        )
        
        return ScanResponse(
            scan_id=scan_id,
            status="queued",
            message=f"Scan {scan_id} has been queued for processing"
        )
        
    except Exception as e:
        logger.error("scan_request_failed", error=str(e))
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/scan/{scan_id}", response_model=ScanStatus)
async def get_scan_status(scan_id: str):
    """Get scan status and results"""
    try:
        scan_data = await mongo_client.get_scan(scan_id)
        
        if not scan_data:
            raise HTTPException(status_code=404, detail="Scan not found")
        
        return ScanStatus(
            scan_id=scan_id,
            status=scan_data["status"],
            progress=scan_data.get("progress", 0),
            vulnerabilities_found=len(scan_data.get("vulnerabilities", [])),
            severity_breakdown=scan_data.get("severity_breakdown", {})
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("get_scan_failed", scan_id=scan_id, error=str(e))
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/scan/{scan_id}/report")
async def get_scan_report(scan_id: str, format: str = "json"):
    """
    Get detailed scan report
    
    Formats: json, html, markdown, pdf
    """
    try:
        scan_data = await mongo_client.get_scan(scan_id)
        
        if not scan_data:
            raise HTTPException(status_code=404, detail="Scan not found")
        
        # Generate report
        report_generator = ReportGenerator()
        report = await report_generator.generate(scan_data, format=format)
        
        return report
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("get_report_failed", scan_id=scan_id, error=str(e))
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/scans")
async def list_scans(limit: int = 50, skip: int = 0):
    """List all scans"""
    try:
        scans = await mongo_client.list_scans(limit=limit, skip=skip)
        return {"scans": scans, "total": len(scans)}
    except Exception as e:
        logger.error("list_scans_failed", error=str(e))
        raise HTTPException(status_code=500, detail=str(e))


async def perform_scan(scan_id: str, request: ScanRequest):
    """Perform the actual security scan"""
    try:
        logger.info("scan_started", scan_id=scan_id)
        
        # Update status
        await mongo_client.update_scan(scan_id, {
            "status": "running",
            "progress": 0
        })
        
        vulnerabilities = []
        scan_types = request.scan_types if "all" not in request.scan_types else [
            "sql", "xss", "csrf", "api", "zap"
        ]
        
        total_scans = len(scan_types)
        completed_scans = 0
        
        # SQL Injection Scan
        if "sql" in scan_types:
            logger.info("running_sql_scan", scan_id=scan_id)
            sql_scanner = SQLInjectionScanner()
            sql_vulns = await sql_scanner.scan(
                request.target_url,
                auth_token=request.auth_token
            )
            vulnerabilities.extend(sql_vulns)
            completed_scans += 1
            await mongo_client.update_scan(scan_id, {
                "progress": int((completed_scans / total_scans) * 100)
            })
        
        # XSS Scan
        if "xss" in scan_types:
            logger.info("running_xss_scan", scan_id=scan_id)
            xss_scanner = XSSScanner()
            xss_vulns = await xss_scanner.scan(
                request.target_url,
                auth_token=request.auth_token
            )
            vulnerabilities.extend(xss_vulns)
            completed_scans += 1
            await mongo_client.update_scan(scan_id, {
                "progress": int((completed_scans / total_scans) * 100)
            })
        
        # CSRF Scan
        if "csrf" in scan_types:
            logger.info("running_csrf_scan", scan_id=scan_id)
            csrf_scanner = CSRFScanner()
            csrf_vulns = await csrf_scanner.scan(
                request.target_url,
                auth_token=request.auth_token
            )
            vulnerabilities.extend(csrf_vulns)
            completed_scans += 1
            await mongo_client.update_scan(scan_id, {
                "progress": int((completed_scans / total_scans) * 100)
            })
        
        # API Testing
        if "api" in scan_types and request.api_endpoints:
            logger.info("running_api_tests", scan_id=scan_id)
            api_tester = APITester()
            api_vulns = await api_tester.test_endpoints(
                request.api_endpoints,
                auth_token=request.auth_token,
                auth_type=request.auth_type
            )
            vulnerabilities.extend(api_vulns)
            completed_scans += 1
            await mongo_client.update_scan(scan_id, {
                "progress": int((completed_scans / total_scans) * 100)
            })
        
        # ZAP Full Scan
        if "zap" in scan_types and zap_scanner:
            logger.info("running_zap_scan", scan_id=scan_id)
            zap_vulns = await zap_scanner.scan(
                request.target_url,
                auth_token=request.auth_token,
                max_depth=request.max_depth
            )
            vulnerabilities.extend(zap_vulns)
            completed_scans += 1
        
        # Calculate severity breakdown
        severity_breakdown = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "info").lower()
            if severity in severity_breakdown:
                severity_breakdown[severity] += 1
        
        # Update final scan results
        await mongo_client.update_scan(scan_id, {
            "status": "completed",
            "progress": 100,
            "vulnerabilities": vulnerabilities,
            "severity_breakdown": severity_breakdown,
            "completed_at": None  # Will be set by MongoDB
        })
        
        logger.info(
            "scan_completed",
            scan_id=scan_id,
            vulnerabilities_found=len(vulnerabilities),
            severity_breakdown=severity_breakdown
        )
        
        # Send notifications for critical findings
        critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
        if critical_vulns:
            notifier = Notifier()
            await notifier.send_critical_alert(scan_id, critical_vulns)
        
    except Exception as e:
        logger.error("scan_failed", scan_id=scan_id, error=str(e))
        await mongo_client.update_scan(scan_id, {
            "status": "failed",
            "error": str(e)
        })


if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=settings.PORT,
        log_level=settings.LOG_LEVEL.lower()
    )
