name: PR Management & Auto-Merge

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - analyze
          - triage
          - auto-merge-ready
          - close-stale
        default: 'analyze'
  schedule:
    # Run daily at 02:00 UTC
    - cron: '0 2 * * *'

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  pr-management:
    runs-on: ubuntu-latest
    name: PR Management
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Determine action
        id: action
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "action=triage" >> $GITHUB_OUTPUT
          else
            echo "action=${{ github.event.inputs.action || 'analyze' }}" >> $GITHUB_OUTPUT
          fi

      - name: Run PR Triage
        if: steps.action.outputs.action == 'triage' || steps.action.outputs.action == 'analyze'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const STATUS_LABELS = ['ready', 'needs-changes', 'blocked', 'stale', 'conflicts'];

            const MERGEABLE_RETRIES = 3;
            const MERGEABLE_RETRY_DELAY_MS = 1500;

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function getPRDetailsWithMergeable(pullNumber) {
              let prDetails = null;

              for (let attempt = 1; attempt <= MERGEABLE_RETRIES; attempt++) {
                const response = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber
                });

                prDetails = response.data;

                if (prDetails.mergeable !== null) {
                  return { prDetails, mergeableResolved: true, attempts: attempt };
                }

                if (attempt < MERGEABLE_RETRIES) {
                  await sleep(MERGEABLE_RETRY_DELAY_MS);
                }
              }

              return { prDetails, mergeableResolved: false, attempts: MERGEABLE_RETRIES };
            }
            
            // Ensure labels exist
            const LABELS = [
              { name: 'ready', color: '0E8A16', description: 'PR is ready to merge' },
              { name: 'needs-changes', color: 'D93F0B', description: 'PR needs fixes' },
              { name: 'blocked', color: 'B60205', description: 'PR is blocked' },
              { name: 'stale', color: '7F8C8D', description: 'PR has been inactive' },
              { name: 'auto-merge', color: '1D76DB', description: 'PR will be auto-merged' },
              { name: 'conflicts', color: 'E99695', description: 'PR has merge conflicts' }
            ];

            for (const label of LABELS) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: label.name });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, ...label });
                  console.log(`Created label: ${label.name}`);
                }
              }
            }

            // Get all open PRs
            const prs = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            console.log(`Found ${prs.length} open PRs`);

            const summary = {
              ready: [],
              needsChanges: [],
              blocked: [],
              stale: [],
              conflicts: [],
              unresolvedMergeable: []
            };

            for (const pr of prs) {
              const { prDetails, mergeableResolved, attempts } = await getPRDetailsWithMergeable(pr.number);
              if (prDetails?.draft ?? pr.draft) continue; // Skip drafts

              const daysSince = Math.floor((Date.now() - new Date(pr.updated_at)) / (1000 * 60 * 60 * 24));
              
              // Check reviews
              const reviews = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: pr.number
              });

              const hasApproval = reviews.data.some(r => r.state === 'APPROVED');
              const hasChangesRequested = reviews.data.some(r => r.state === 'CHANGES_REQUESTED');

              // Check CI status
              const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
                owner,
                repo,
                ref: pr.head.sha
              });

              const ciPassing = combinedStatus.data.state === 'success';
              const existingLabels = pr.labels.map(l => l.name);

              let newLabel = null;
              let reason = '';

              // Classification logic
              if (!mergeableResolved) {
                newLabel = 'blocked';
                reason = `Mergeability still null after ${attempts} checks`;
                summary.unresolvedMergeable.push({ number: pr.number, title: pr.title, attempts });
              } else if (prDetails?.mergeable === false) {
                newLabel = 'conflicts';
                reason = 'Has merge conflicts';
                summary.conflicts.push({ number: pr.number, title: pr.title });
              } else if (daysSince >= 14) {
                newLabel = 'stale';
                reason = `Inactive for ${daysSince} days`;
                summary.stale.push({ number: pr.number, title: pr.title, days: daysSince });
              } else if (hasChangesRequested || !ciPassing) {
                newLabel = 'needs-changes';
                reason = hasChangesRequested ? 'Changes requested' : 'CI failing';
                summary.needsChanges.push({ number: pr.number, title: pr.title });
              } else if (hasApproval && ciPassing) {
                newLabel = 'ready';
                reason = 'Ready to merge';
                summary.ready.push({ number: pr.number, title: pr.title });
              } else {
                newLabel = 'needs-changes';
                reason = 'Needs review and approval';
                summary.needsChanges.push({ number: pr.number, title: pr.title });
              }

              // Update labels
              const labelsToRemove = existingLabels.filter(l => 
                STATUS_LABELS.includes(l) && l !== newLabel
              );

              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: label
                  });
                } catch (e) {}
              }

              if (!existingLabels.includes(newLabel)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.number,
                  labels: [newLabel]
                });
              }

              console.log(`#${pr.number}: ${newLabel} - ${reason}`);
            }

            // Generate summary issue comment
            const summaryText = [
              '## ğŸ“Š PR Management Summary',
              '',
              `**Total Open PRs:** ${prs.length}`,
              '',
              `### âœ… Ready to Merge (${summary.ready.length})`,
              summary.ready.length > 0 ? summary.ready.map(p => `- #${p.number}: ${p.title}`).join('\n') : '*None*',
              '',
              `### âš ï¸ Needs Changes (${summary.needsChanges.length})`,
              summary.needsChanges.length > 0 ? summary.needsChanges.map(p => `- #${p.number}: ${p.title}`).join('\n') : '*None*',
              '',
              `### âš”ï¸ Has Conflicts (${summary.conflicts.length})`,
              summary.conflicts.length > 0 ? summary.conflicts.map(p => `- #${p.number}: ${p.title}`).join('\n') : '*None*',
              '',
              `### â³ Mergeability Pending (${summary.unresolvedMergeable.length})`,
              summary.unresolvedMergeable.length > 0 ? summary.unresolvedMergeable.map(p => `- #${p.number}: ${p.title} (null after ${p.attempts} checks)`).join('\n') : '*None*',
              '',
              `### ğŸ•°ï¸ Stale (${summary.stale.length})`,
              summary.stale.length > 0 ? summary.stale.map(p => `- #${p.number}: ${p.title} (${p.days}d)`).join('\n') : '*None*',
              '',
              '---',
              `*Last updated: ${new Date().toISOString()}*`,
              '*Automated by PR Management workflow*'
            ].join('\n');

            core.summary.addRaw(summaryText);
            await core.summary.write();

      - name: Auto-merge ready PRs
        if: steps.action.outputs.action == 'auto-merge-ready'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Get PRs labeled as 'ready'
            const prs = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const MERGEABLE_RETRIES = 3;
            const MERGEABLE_RETRY_DELAY_MS = 1500;
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function getPRDetailsWithMergeable(pullNumber) {
              let prDetails = null;

              for (let attempt = 1; attempt <= MERGEABLE_RETRIES; attempt++) {
                const response = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber
                });
                prDetails = response.data;

                if (prDetails.mergeable !== null) {
                  return { prDetails, mergeableResolved: true, attempts: attempt };
                }

                if (attempt < MERGEABLE_RETRIES) {
                  await sleep(MERGEABLE_RETRY_DELAY_MS);
                }
              }

              return { prDetails, mergeableResolved: false, attempts: MERGEABLE_RETRIES };
            }

            const readyPRs = prs.filter(pr => 
              !pr.draft && pr.labels.some(l => l.name === 'ready')
            );

            console.log(`Found ${readyPRs.length} PRs ready for auto-merge`);

            for (const pr of readyPRs) {
              try {
                const { prDetails, mergeableResolved, attempts } = await getPRDetailsWithMergeable(pr.number);

                if (!mergeableResolved) {
                  console.log(`â³ Skipping #${pr.number}: mergeable is still null after ${attempts} checks`);
                  continue;
                }

                if (prDetails?.mergeable === false) {
                  console.log(`âš”ï¸ Skipping #${pr.number}: merge conflicts detected via pulls.get`);
                  continue;
                }
                // Add auto-merge label
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.number,
                  labels: ['auto-merge']
                });

                // Attempt to merge
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: `Merge #${pr.number}: ${pr.title}`,
                  commit_message: 'Automated merge via PR Management workflow'
                });

                console.log(`âœ… Merged #${pr.number}`);
              } catch (error) {
                console.log(`âŒ Failed to merge #${pr.number}: ${error.message}`);
              }
            }

      - name: Close stale PRs
        if: steps.action.outputs.action == 'close-stale'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const prs = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const MERGEABLE_RETRIES = 3;
            const MERGEABLE_RETRY_DELAY_MS = 1500;
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function getPRDetailsWithMergeable(pullNumber) {
              let prDetails = null;

              for (let attempt = 1; attempt <= MERGEABLE_RETRIES; attempt++) {
                const response = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber
                });
                prDetails = response.data;

                if (prDetails.mergeable !== null) {
                  return { prDetails, mergeableResolved: true, attempts: attempt };
                }

                if (attempt < MERGEABLE_RETRIES) {
                  await sleep(MERGEABLE_RETRY_DELAY_MS);
                }
              }

              return { prDetails, mergeableResolved: false, attempts: MERGEABLE_RETRIES };
            }

            const stalePRs = [];
            const unresolvedMergeability = [];

            for (const pr of prs) {
              const daysSince = Math.floor((Date.now() - new Date(pr.updated_at)) / (1000 * 60 * 60 * 24));
              if (daysSince < 30 || !pr.labels.some(l => l.name === 'stale')) {
                continue;
              }

              const { mergeableResolved, attempts } = await getPRDetailsWithMergeable(pr.number);
              if (!mergeableResolved) {
                unresolvedMergeability.push({ number: pr.number, attempts });
                continue;
              }

              stalePRs.push(pr);
            }

            console.log(`Found ${stalePRs.length} stale PRs to close`);
            if (unresolvedMergeability.length > 0) {
              console.log(`â³ Skipped ${unresolvedMergeability.length} stale PR(s): mergeable still null after retries`);
            }

            for (const pr of stalePRs) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body: 'Ø¥ØºÙ„Ø§Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠ: Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ Ù„Ù… ÙŠØ´Ù‡Ø¯ Ù†Ø´Ø§Ø·Ø§Ù‹ Ù…Ù†Ø° 30 ÙŠÙˆÙ…. ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© ÙØªØ­Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©.'
              });

              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr.number,
                state: 'closed'
              });

              console.log(`Closed #${pr.number}`);
            }
