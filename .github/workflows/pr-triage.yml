name: PR Triage and Status Management

on:
  workflow_dispatch:
  schedule:
    # Every 48 hours at 08:00 UTC
    - cron: '0 8 */2 * *'

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage open pull requests
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const STATUS_LABELS = ['ready', 'needs-changes', 'blocked', 'stale'];
            const STATIC_LABELS = [
              { name: 'ready', color: '0E8A16', description: 'PR is ready to merge' },
              { name: 'needs-changes', color: 'D93F0B', description: 'PR needs fixes before merge' },
              { name: 'blocked', color: 'B60205', description: 'PR is blocked by dependency or product decision' },
              { name: 'stale', color: '7F8C8D', description: 'PR has been inactive for a while' },
              { name: 'priority-high', color: '5319E7', description: 'High-priority pull request' }
            ];

            async function ensureLabel(label) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: label.name });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, ...label });
                  core.info(`Created label: ${label.name}`);
                  return;
                }
                throw error;
              }
            }

            for (const label of STATIC_LABELS) {
              await ensureLabel(label);
            }

            function daysSince(dateString) {
              const updated = new Date(dateString).getTime();
              const now = Date.now();
              return (now - updated) / (1000 * 60 * 60 * 24);
            }

            function classifyPR(pr, reviews, checkState) {
              const labelNames = (pr.labels || []).map(l => l.name.toLowerCase());
              const reviewStates = reviews.map(r => r.state);
              const hasRequestedChanges = reviewStates.includes('CHANGES_REQUESTED');
              const hasApproval = reviewStates.includes('APPROVED');
              const inactiveDays = daysSince(pr.updated_at);

              const blockedByLabel = labelNames.some(name => [
                'blocked', 'dependencies', 'dependency', 'product-decision', 'waiting-on-product', 'on-hold'
              ].includes(name));

              if (inactiveDays >= 14) {
                return {
                  status: 'stale',
                  reason: `لا يوجد نشاط منذ ${Math.floor(inactiveDays)} يوم.` ,
                  next: 'تأكيد استمرار الحاجة إلى PR أو تحديثه لإزالته من حالة stale.'
                };
              }

              if (blockedByLabel) {
                return {
                  status: 'blocked',
                  reason: 'الـ PR مرتبط باعتماد خارجي أو قرار منتج ولم يكتمل بعد.',
                  next: 'إزالة سبب الحظر (dependency/قرار منتج) ثم إعادة التقييم.'
                };
              }

              if (pr.draft || hasRequestedChanges || checkState !== 'SUCCESS') {
                const failingChecks = checkState === 'FAILURE' ? 'مع وجود فشل في الفحوصات.' : '';
                const draftReason = pr.draft ? 'الـ PR لا يزال Draft.' : '';
                const reviewReason = hasRequestedChanges ? 'توجد ملاحظات مراجعة تتطلب تعديلات.' : '';
                const reasonText = [draftReason, reviewReason, failingChecks].filter(Boolean).join(' ');

                return {
                  status: 'needs-changes',
                  reason: reasonText || 'يحتاج تعديلات قبل الدمج.',
                  next: 'تنفيذ التعديلات المطلوبة ثم طلب مراجعة جديدة.'
                };
              }

              if (hasApproval && checkState === 'SUCCESS' && !pr.draft) {
                return {
                  status: 'ready',
                  reason: 'الـ PR حاصل على موافقة والمراجعات/الفحوصات ناجحة.',
                  next: 'الدمج إلى الفرع الرئيسي حسب سياسة الفريق.'
                };
              }

              return {
                status: 'needs-changes',
                reason: 'الـ PR لم يصل بعد إلى شروط الجاهزية للدمج.',
                next: 'استكمال المراجعات والفحوصات ثم إعادة التصنيف.'
              };
            }

            function buildComment(statusInfo) {
              return [
                '<!-- pr-triage-status -->',
                `الحالة: **${statusInfo.status}**`,
                `سبب الحالة: ${statusInfo.reason}`,
                `الخطوة التالية: ${statusInfo.next}`
              ].join('\n');
            }

            const prs = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            core.info(`Found ${prs.length} open PR(s).`);

            for (const pr of prs) {
              const [reviews, combinedStatus, comments] = await Promise.all([
                github.paginate(github.rest.pulls.listReviews, {
                  owner,
                  repo,
                  pull_number: pr.number,
                  per_page: 100
                }),
                github.rest.repos.getCombinedStatusForRef({
                  owner,
                  repo,
                  ref: pr.head.sha
                }),
                github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: pr.number,
                  per_page: 100
                })
              ]);

              const checkState = combinedStatus.data.state === 'pending'
                ? 'PENDING'
                : combinedStatus.data.state.toUpperCase();

              const statusInfo = classifyPR(pr, reviews, checkState);
              const statusLabel = statusInfo.status;

              const existingLabels = (pr.labels || []).map(l => l.name);
              const labelsToRemove = existingLabels.filter(name => STATUS_LABELS.includes(name) && name !== statusLabel);

              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: label
                  });
                } catch (error) {
                  if (error.status !== 404) {
                    throw error;
                  }
                }
              }

              if (!existingLabels.includes(statusLabel)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.number,
                  labels: [statusLabel]
                });
              }

              const body = buildComment(statusInfo);
              const existingComment = comments.find(c => c.body && c.body.includes('<!-- pr-triage-status -->'));

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existingComment.id,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body
                });
              }

              core.info(`#${pr.number}: ${statusLabel}`);
            }
